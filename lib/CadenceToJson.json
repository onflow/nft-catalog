{"transactions":{"add_to_nft_catalog":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(\n    collectionIdentifier : String,\n    contractName: String,\n    contractAddress: Address,\n    nftTypeIdentifer: String,\n    addressWithNFT: Address,\n    nftID: UInt64,\n    publicPathIdentifier: String\n) {\n    let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n    prepare(acct: AuthAccount) {\n        self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n    }\n\n    execute {\n        let nftAccount = getAccount(addressWithNFT)\n        let pubPath = PublicPath(identifier: publicPathIdentifier)!\n        let collectionCap = nftAccount.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(pubPath)\n        assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n        let collectionRef = collectionCap.borrow()!\n        assert(collectionRef.getIDs().length > 0, message: \"No NFTs exist in this collection.\")\n        let nftResolver = collectionRef.borrowViewResolver(id: nftID)\n        \n        let metadataCollectionData = nftResolver.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData\n        \n        let collectionData = NFTCatalog.NFTCollectionData(\n            storagePath: metadataCollectionData.storagePath,\n            publicPath: metadataCollectionData.publicPath,\n            privatePath: metadataCollectionData.providerPath,\n            publicLinkedType : metadataCollectionData.publicLinkedType,\n            privateLinkedType : metadataCollectionData.providerLinkedType\n        )\n\n        let collectionDisplay = nftResolver.resolveView(Type<MetadataViews.NFTCollectionDisplay>())! as! MetadataViews.NFTCollectionDisplay\n\n        let catalogData = NFTCatalog.NFTCatalogMetadata(\n            contractName: contractName,\n            contractAddress: contractAddress,\n            nftType: CompositeType(nftTypeIdentifer)!,\n            collectionData: collectionData,\n            collectionDisplay : collectionDisplay\n        )\n        \n        self.adminProxyResource.getCapability()!.borrow()!.addCatalogEntry(collectionIdentifier : collectionIdentifier, metadata : catalogData)\n    }\n}","add_to_nft_catalog_admin":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(\n    collectionIdentifier : String,\n    contractName: String,\n    contractAddress: Address,\n    nftTypeIdentifer: String,\n    addressWithNFT: Address,\n    nftID: UInt64,\n    publicPathIdentifier: String\n) {\n    \n    let adminResource: &NFTCatalogAdmin.Admin\n    \n    prepare(acct: AuthAccount) {\n        self.adminResource = acct.borrow<&NFTCatalogAdmin.Admin>(from: NFTCatalogAdmin.AdminStoragePath)!\n    }\n    \n    execute {\n        let nftAccount = getAccount(addressWithNFT)\n        let pubPath = PublicPath(identifier: publicPathIdentifier)!\n        let collectionCap = nftAccount.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(pubPath)\n        assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n        let collectionRef = collectionCap.borrow()!\n        assert(collectionRef.getIDs().length > 0, message: \"No NFTs exist in this collection.\")\n        let nftResolver = collectionRef.borrowViewResolver(id: nftID)\n        \n        let metadataCollectionData = nftResolver.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData\n        \n        let collectionData = NFTCatalog.NFTCollectionData(\n            storagePath: metadataCollectionData.storagePath,\n            publicPath: metadataCollectionData.publicPath,\n            privatePath: metadataCollectionData.providerPath,\n            publicLinkedType : metadataCollectionData.publicLinkedType,\n            privateLinkedType : metadataCollectionData.providerLinkedType\n        )\n\n        let collectionDisplay = nftResolver.resolveView(Type<MetadataViews.NFTCollectionDisplay>())! as! MetadataViews.NFTCollectionDisplay\n\n        let catalogData = NFTCatalog.NFTCatalogMetadata(\n            contractName: contractName,\n            contractAddress: contractAddress,\n            nftType: CompositeType(nftTypeIdentifer)!,\n            collectionData: collectionData,\n            collectionDisplay : collectionDisplay\n        )\n\n        self.adminResource.addCatalogEntry(collectionIdentifier : collectionIdentifier, metadata : catalogData)\n    }\n}","approve_nft_catalog_proposal":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(proposalID : UInt64) {\n    let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n    prepare(acct: AuthAccount) {\n        self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n    }\n\n    execute {\n        self.adminProxyResource.getCapability()!.borrow()!.approveCatalogProposal(proposalID : proposalID)\n    }\n}","mint_example_nft":"import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\nimport MetadataViews from 0xMetadataViews\nimport FungibleToken from 0xFungibleToken\n\n// This script uses the NFTMinter resource to mint a new NFT\n// It must be run with the account that has the minter resource\n// stored in /storage/NFTMinter\n\ntransaction(\n    recipient: Address,\n    name: String,\n    description: String,\n    thumbnail: String,\n    cuts: [UFix64],\n    royaltyDescriptions: [String],\n    royaltyBeneficiaries: [Address]\n) {\n\n    // local variable for storing the minter reference\n    let minter: &ExampleNFT.NFTMinter\n\n    let royalties: [MetadataViews.Royalty]\n\n\n    prepare(signer: AuthAccount) {\n        // borrow a reference to the NFTMinter resource in storage\n        self.minter = signer.borrow<&ExampleNFT.NFTMinter>(from: ExampleNFT.MinterStoragePath)\n            ?? panic(\"Could not borrow a reference to the NFT minter\")\n        \n        // creating the royalty details\n        var count = 0\n        self.royalties = []\n        while royaltyBeneficiaries.length > count {\n            let beneficiary = royaltyBeneficiaries[count]\n            let beneficiaryCapability = getAccount(beneficiary)\n            .getCapability<&{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())\n\n            // Make sure the royalty capability is valid before minting the NFT\n            if !beneficiaryCapability.check() { panic(\"Beneficiary capability is not valid!\") }\n\n            self.royalties.append(\n                MetadataViews.Royalty(\n                    recepient: beneficiaryCapability,\n                    cut: cuts[count],\n                    description: royaltyDescriptions[count]\n                )\n            )\n            count = count + 1\n        }\n    }\n\n    pre {\n        cuts.length == royaltyDescriptions.length && cuts.length == royaltyBeneficiaries.length: \"Array length should be equal for royalty related details\"\n    }\n\n    execute {\n        // Borrow the recipient's public NFT collection reference\n        let receiver = getAccount(recipient)\n            .getCapability(ExampleNFT.CollectionPublicPath)\n            .borrow<&{NonFungibleToken.CollectionPublic}>()\n            ?? panic(\"Could not get receiver reference to the NFT Collection\")\n\n        // Mint the NFT and deposit it to the recipient's collection\n        self.minter.mintNFT(\n            recipient: receiver,\n            name: name,\n            description: description,\n            thumbnail: thumbnail,\n            royalties: self.royalties\n        )\n    }\n}\n ","mint_nonstandard_nft":"import NonFungibleToken from 0xNonFungibleToken\nimport NonStandardNFT from 0xNonStandardNFT\nimport MetadataViews from 0xMetadataViews\nimport FungibleToken from 0xFungibleToken\n\n// This script uses the NFTMinter resource to mint a new NFT\n// It must be run with the account that has the minter resource\n// stored in /storage/NFTMinter\n\ntransaction(\n    recipient: Address,\n    name: String,\n    description: String,\n    thumbnail: String,\n    cuts: [UFix64],\n    royaltyDescriptions: [String],\n    royaltyBeneficiaries: [Address]\n) {\n\n    // local variable for storing the minter reference\n    let minter: &NonStandardNFT.NFTMinter\n\n    let royalties: [MetadataViews.Royalty]\n\n\n    prepare(signer: AuthAccount) {\n        // borrow a reference to the NFTMinter resource in storage\n        self.minter = signer.borrow<&NonStandardNFT.NFTMinter>(from: NonStandardNFT.MinterStoragePath)\n            ?? panic(\"Could not borrow a reference to the NFT minter\")\n        \n        // creating the royalty details\n        var count = 0\n        self.royalties = []\n        while royaltyBeneficiaries.length > count {\n            let beneficiary = royaltyBeneficiaries[count]\n            let beneficiaryCapability = getAccount(beneficiary)\n            .getCapability<&{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())\n\n            // Make sure the royalty capability is valid before minting the NFT\n            if !beneficiaryCapability.check() { panic(\"Beneficiary capability is not valid!\") }\n\n            self.royalties.append(\n                MetadataViews.Royalty(\n                    recepient: beneficiaryCapability,\n                    cut: cuts[count],\n                    description: royaltyDescriptions[count]\n                )\n            )\n            count = count + 1\n        }\n    }\n\n    pre {\n        cuts.length == royaltyDescriptions.length && cuts.length == royaltyBeneficiaries.length: \"Array length should be equal for royalty related details\"\n    }\n\n    execute {\n        // Borrow the recipient's public NFT collection reference\n        let receiver = getAccount(recipient)\n            .getCapability(NonStandardNFT.CollectionPublicPath)\n            .borrow<&{NonFungibleToken.CollectionPublic}>()\n            ?? panic(\"Could not get receiver reference to the NFT Collection\")\n\n        // Mint the NFT and deposit it to the recipient's collection\n        self.minter.mintNFT(\n            recipient: receiver,\n            name: name,\n            description: description,\n            thumbnail: thumbnail,\n            royalties: self.royalties\n        )\n    }\n}\n ","propose_nft_to_catalog":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\n\ntransaction(\n    collectionIdentifier : String,\n    contractName: String,\n    contractAddress: Address,\n    nftTypeIdentifer: String,\n    storagePathIdentifier: String,\n    publicPathIdentifier: String,\n    privatePathIdentifier: String,\n    publicLinkedTypeIdentifier : String,\n    publicLinkedTypeRestrictions : [String],\n    privateLinkedTypeIdentifier : String,\n    privateLinkedTypeRestrictions : [String],\n    collectionName : String,\n    collectionDescription: String,\n    externalURL : String,\n    squareImageMediaURL : String,\n    squareImageMediaType : String,\n    bannerImageMediaURL : String,\n    bannerImageMediaType : String,\n    socials: {String : String},\n    message: String\n) {\n\n    let nftCatalogProposalResourceRef : &NFTCatalog.NFTCatalogProposalManager\n    \n    prepare(acct: AuthAccount) {\n        \n        if acct.borrow<&NFTCatalog.NFTCatalogProposalManager>(from: NFTCatalog.ProposalManagerStoragePath) == nil {\n             let proposalManager <- NFTCatalog.createNFTCatalogProposalManager()\n             acct.save(<-proposalManager, to: NFTCatalog.ProposalManagerStoragePath)\n             acct.link<&NFTCatalog.NFTCatalogProposalManager{NFTCatalog.NFTCatalogProposalManagerPublic}>(NFTCatalog.ProposalManagerPublicPath, target: NFTCatalog.ProposalManagerStoragePath)\n        }\n\n        self.nftCatalogProposalResourceRef = acct.borrow<&NFTCatalog.NFTCatalogProposalManager>(from: NFTCatalog.ProposalManagerStoragePath)!\n    }\n    \n    execute {\n        var privateLinkedType: Type? = nil\n        if (privateLinkedTypeRestrictions.length == 0) {\n            privateLinkedType = CompositeType(publicLinkedTypeIdentifier)\n        } else {\n            privateLinkedType = RestrictedType(identifier : privateLinkedTypeIdentifier, restrictions: privateLinkedTypeRestrictions)\n        }\n        \n        let collectionData = NFTCatalog.NFTCollectionData(\n            storagePath: StoragePath(identifier: storagePathIdentifier)!,\n            publicPath: PublicPath(identifier : publicPathIdentifier)!,\n            privatePath: PrivatePath(identifier: privatePathIdentifier)!,\n            publicLinkedType : RestrictedType(identifier : publicLinkedTypeIdentifier, restrictions: publicLinkedTypeRestrictions)!,\n            privateLinkedType : privateLinkedType!\n        )\n\n        let squareMedia = MetadataViews.Media(\n                        file: MetadataViews.HTTPFile(\n                            url: squareImageMediaURL\n                        ),\n                        mediaType: squareImageMediaType\n                    )\n        \n        let bannerMedia = MetadataViews.Media(\n                        file: MetadataViews.HTTPFile(\n                            url: bannerImageMediaURL\n                        ),\n                        mediaType: bannerImageMediaType\n                    )\n\n        let socialsStruct : {String : MetadataViews.ExternalURL} = {}\n        for key in socials.keys {\n            socialsStruct[key] =  MetadataViews.ExternalURL(socials[key]!)\n        }\n        \n        let collectionDisplay = MetadataViews.NFTCollectionDisplay(\n            name: collectionName,\n            description: collectionDescription,\n            externalURL: MetadataViews.ExternalURL(externalURL),\n            squareImage: squareMedia,\n            bannerImage: bannerMedia,\n            socials: socialsStruct\n        )\n\n        let catalogData = NFTCatalog.NFTCatalogMetadata(\n            contractName: contractName,\n            contractAddress: contractAddress,\n            nftType: CompositeType(nftTypeIdentifer)!,\n            collectionData: collectionData,\n            collectionDisplay : collectionDisplay\n        )\n\n        self.nftCatalogProposalResourceRef.setCurrentProposalEntry(identifier : collectionIdentifier)\n\n        NFTCatalog.proposeNFTMetadata(collectionIdentifier : collectionIdentifier, metadata : catalogData, message: message, proposer: self.nftCatalogProposalResourceRef.owner!.address)\n\n        self.nftCatalogProposalResourceRef.setCurrentProposalEntry(identifier : nil)\n    }\n}","reject_nft_catalog_proposal":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(proposalID : UInt64) {\n    let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n    prepare(acct: AuthAccount) {\n        self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n    }\n\n    execute {\n        self.adminProxyResource.getCapability()!.borrow()!.rejectCatalogProposal(proposalID : proposalID)\n    }\n}","remove_from_nft_catalog":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(\n    collectionIdentifier : String\n) {\n    let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n    prepare(acct: AuthAccount) {\n        self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n    }\n\n    execute {     \n        self.adminProxyResource.getCapability()!.borrow()!.removeCatalogEntry(collectionIdentifier : collectionIdentifier)\n    }\n}","remove_nft_catalog_proposal":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(proposalID : UInt64) {\n    let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n    prepare(acct: AuthAccount) {\n        self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n    }\n\n    execute {\n        self.adminProxyResource.getCapability()!.borrow()!.removeCatalogProposal(proposalID : proposalID)\n    }\n}","send_admin_capability_to_proxy":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(proxyAddress: Address) {\n    let adminCap : Capability<&NFTCatalogAdmin.Admin>\n    \n    prepare(acct: AuthAccount) {\n        self.adminCap = acct.getCapability<&NFTCatalogAdmin.Admin>(NFTCatalogAdmin.AdminPrivatePath)\n    }\n\n    execute {\n        let owner = getAccount(proxyAddress)\n        let proxy = owner.getCapability<&NFTCatalogAdmin.AdminProxy{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath)\n            .borrow() ?? panic(\"Could not borrow Admin Proxy\")\n        \n        proxy.addCapability(capability : self.adminCap)\n    }\n}","setup_examplenft_collection":"import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\nimport MetadataViews from 0xMetadataViews\n\n// This transaction is what an account would run\n// to set itself up to receive NFTs\n\ntransaction {\n\n    prepare(signer: AuthAccount) {\n        // Return early if the account already has a collection\n        if signer.borrow<&ExampleNFT.Collection>(from: ExampleNFT.CollectionStoragePath) != nil {\n            return\n        }\n\n        // Create a new empty collection\n        let collection <- ExampleNFT.createEmptyCollection()\n\n        // save it to the account\n        signer.save(<-collection, to: ExampleNFT.CollectionStoragePath)\n\n        // create a public capability for the collection\n        signer.link<&{NonFungibleToken.CollectionPublic, ExampleNFT.ExampleNFTCollectionPublic, MetadataViews.ResolverCollection}>(\n            ExampleNFT.CollectionPublicPath,\n            target: ExampleNFT.CollectionStoragePath\n        )\n    }\n}","setup_nft_catalog_admin_proxy":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction() {\n    \n    prepare(acct: AuthAccount) {\n        acct.save(<- NFTCatalogAdmin.createAdminProxy(), to: NFTCatalogAdmin.AdminProxyStoragePath)\n        acct.link<&NFTCatalogAdmin.AdminProxy{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath, target: NFTCatalogAdmin.AdminProxyStoragePath)\n    }\n}","setup_nonstandardnft_collection":"import NonFungibleToken from 0xNonFungibleToken\nimport NonStandardNFT from 0xNonStandardNFT\nimport MetadataViews from 0xMetadataViews\n\n// This transaction is what an account would run\n// to set itself up to receive NFTs\n\ntransaction {\n\n    prepare(signer: AuthAccount) {\n        // Return early if the account already has a collection\n        if signer.borrow<&NonStandardNFT.Collection>(from: NonStandardNFT.CollectionStoragePath) != nil {\n            return\n        }\n\n        // Create a new empty collection\n        let collection <- NonStandardNFT.createEmptyCollection()\n\n        // save it to the account\n        signer.save(<-collection, to: NonStandardNFT.CollectionStoragePath)\n\n        // create a public capability for the collection\n        signer.link<&{NonFungibleToken.CollectionPublic, NonStandardNFT.NonStandardNFTCollectionPublic, MetadataViews.ResolverCollection}>(\n            NonStandardNFT.CollectionPublicPath,\n            target: NonStandardNFT.CollectionStoragePath\n        )\n    }\n}","setup_storefront":"import NFTStorefrontV2 from 0xNFTStorefrontV2\n\n// This transaction installs the Storefront ressource in an account.\n\ntransaction {\n    prepare(acct: AuthAccount) {\n\n        // If the account doesn't already have a Storefront\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            \n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n    }\n}\n ","transfer_examplenft":"import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\n\n// This transaction is for transferring and NFT from\n// one account to another\n\ntransaction(recipient: Address, withdrawID: UInt64) {\n\n    prepare(signer: AuthAccount) {\n        // get the recipients public account object\n        let recipient = getAccount(recipient)\n\n        // borrow a reference to the signer's NFT collection\n        let collectionRef = signer\n            .borrow<&ExampleNFT.Collection>(from: ExampleNFT.CollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to the owner's collection\")\n\n        // borrow a public reference to the receivers collection\n        let depositRef = recipient\n            .getCapability(ExampleNFT.CollectionPublicPath)\n            .borrow<&{NonFungibleToken.CollectionPublic}>()\n            ?? panic(\"Could not borrow a reference to the receiver's collection\")\n\n        // withdraw the NFT from the owner's collection\n        let nft <- collectionRef.withdraw(withdrawID: withdrawID)\n\n        // Deposit the NFT in the recipient's collection\n        depositRef.deposit(token: <-nft)\n    }\n}","update_nft_catalog_entry":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(\n        collectionIdentifier : String,\n        contractName: String,\n        contractAddress: Address,\n        nftTypeIdentifer: String,\n        addressWithNFT: Address,\n        publicPathIdentifier: String\n) {\n        let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n        prepare(acct: AuthAccount) {\n                self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n        }\n\n        execute {\n                let nftAccount = getAccount(addressWithNFT)\n                let pubPath = PublicPath(identifier: publicPathIdentifier)!\n                let collectionCap = nftAccount.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(pubPath)\n                assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n                let collectionRef = collectionCap.borrow()!\n                assert(collectionRef.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n                let testNftId = collectionRef.getIDs()[0]\n                let nftResolver = collectionRef.borrowViewResolver(id: testNftId)\n                \n                let metadataCollectionData = nftResolver.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData\n                \n                let collectionData = NFTCatalog.NFTCollectionData(\n                        storagePath: metadataCollectionData.storagePath,\n                        publicPath: metadataCollectionData.publicPath,\n                        privatePath: metadataCollectionData.providerPath,\n                        publicLinkedType : metadataCollectionData.publicLinkedType,\n                        privateLinkedType : metadataCollectionData.providerLinkedType\n                )\n\n                let collectionDisplay = nftResolver.resolveView(Type<MetadataViews.NFTCollectionDisplay>())! as! MetadataViews.NFTCollectionDisplay\n\n                let catalogData = NFTCatalog.NFTCatalogMetadata(\n                        contractName: contractName,\n                        contractAddress: contractAddress,\n                        nftType: CompositeType(nftTypeIdentifer)!,\n                        collectionData: collectionData,\n                        collectionDisplay : collectionDisplay\n                )\n                \n                self.adminProxyResource.getCapability()!.borrow()!.updateCatalogEntry(collectionIdentifier : collectionIdentifier, metadata : catalogData)\n        }\n}","withdraw_nft_proposal_from_catalog":"import NFTCatalog from 0xNFTCatalog\n\ntransaction(\n    proposalID : UInt64\n) {\n    let nftCatalogProposalResourceRef : &NFTCatalog.NFTCatalogProposalManager\n\n    prepare(acct: AuthAccount) {\n        self.nftCatalogProposalResourceRef = acct.borrow<&NFTCatalog.NFTCatalogProposalManager>(from: NFTCatalog.ProposalManagerStoragePath)!\n    }\n\n    execute {\n        let proposal = NFTCatalog.getCatalogProposalEntry(proposalID: proposalID)!\n        \n        self.nftCatalogProposalResourceRef.setCurrentProposalEntry(identifier : proposal.collectionIdentifier)\n        NFTCatalog.withdrawNFTProposal(proposalID : proposalID)\n        self.nftCatalogProposalResourceRef.setCurrentProposalEntry(identifier : nil)\n    }\n}"},"scripts":{"check_for_recommended_v1_views":"import MetadataViews from 0xMetadataViews\nimport NFTRetrieval from 0xNFTRetrieval\n\n/*\n    Script to check for the implementation of all recommended MetadataViews.\n */\npub fun main(ownerAddress: Address, collectionStoragePath: StoragePath): {String: Bool} {\n    let owner = getAuthAccount(ownerAddress)\n    let tempPathStr = \"recommnededV1ViewsNFTCatalog\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    owner.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: collectionStoragePath\n    )\n    \n    let collectionCap = owner.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n    assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n    let collection = collectionCap.borrow()!\n    assert(collection.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n    let testNFTID = collection.getIDs()[0]\n    let nftResolver = collection.borrowViewResolver(id: testNFTID)\n    let views: {String: Bool} = {}\n    // Initialize map to all falses for recommended views.\n    for view in NFTRetrieval.getRecommendedViewsTypes(version: \"v1\") {\n        views.insert(key: view.identifier, false)\n    }\n    // Set to true if supported.\n    for view in nftResolver.getViews() {\n        if views.containsKey(view.identifier) {\n            views.insert(key: view.identifier, true)\n        }\n    }\n    return views\n}","gen_tx":"import TransactionGeneration from 0xTransactionGeneration\n\npub fun main(tx: String, collectionIdentifier: String, vaultIdentifier: String, merchantAddress: String) : String {\n    return TransactionGeneration.getTx(tx: tx, params: {\n        \"collectionIdentifier\": collectionIdentifier,\n        \"vaultIdentifier\": vaultIdentifier,\n        \"merchantAddress\": merchantAddress\n    })!\n}\n","get_all_nfts_and_views_in_account":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct NFTCollectionData {\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n\n    init(\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n    ) {\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n    }\n}\n\npub fun main(ownerAddress: Address) : { String : {String : AnyStruct} }  {\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n    let items : [MetadataViews.NFTView] = []\n    \n    let data : { String : {String : AnyStruct} } = {}\n\n    for key in catalog.keys {\n        let value = catalog[key]!\n        let tempPathStr = \"catalog\".concat(key)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: value.collectionData.storagePath\n        )\n        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n        if !collectionCap.check() {\n            continue\n        }\n        \n        var views = NFTRetrieval.getAllMetadataViewsFromCap(collectionIdentifier : key, collectionCap : collectionCap)\n        \n        if views.keys.length == 0 {\n            continue\n        }\n        \n        // Cadence doesn't support function return types, lets manually get rid of it\n        let nftCollectionDisplayView = views[Type<MetadataViews.NFTCollectionData>().identifier] as! MetadataViews.NFTCollectionData?\n        let collectionDataView = NFTCollectionData(\n                    storagePath : nftCollectionDisplayView!.storagePath,\n                    publicPath : nftCollectionDisplayView!.publicPath,\n                    privatePath : nftCollectionDisplayView!.providerPath,\n                    publicLinkedType : nftCollectionDisplayView!.publicLinkedType,\n                    privateLinkedType : nftCollectionDisplayView!.providerLinkedType,\n        )\n        views.insert(key: Type<MetadataViews.NFTCollectionData>().identifier, collectionDataView)\n        \n        data[key] = views\n    }\n\n    return data\n}\n","get_all_nfts_in_account":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct NFT {\n    pub let id : UInt64\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n    pub let externalURL : String\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : String\n    pub let collectionBannerImage : String\n    pub let collectionExternalURL : String\n    pub let royalties: [MetadataViews.Royalty]\n\n    init(\n            id: UInt64,\n            name : String,\n            description : String,\n            thumbnail : String,\n            externalURL : String,\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n            collectionName : String,\n            collectionDescription : String,\n            collectionSquareImage : String,\n            collectionBannerImage : String,\n            collectionExternalURL : String,\n            royalties : [MetadataViews.Royalty]\n    ) {\n        self.id = id\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n        self.externalURL = externalURL\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.collectionExternalURL = collectionExternalURL\n        self.royalties = royalties\n    }\n}\n\npub fun main(ownerAddress: Address) : { String : [NFT] } {\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n    let items : [MetadataViews.NFTView] = []\n    \n    let data : {String : [NFT] } = {}\n\n    for key in catalog.keys {\n        let value = catalog[key]!\n        let tempPathStr = \"catalog\".concat(key)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: value.collectionData.storagePath\n        )\n        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n        if !collectionCap.check() {\n            continue\n        }\n        let views = NFTRetrieval.getNFTViewsFromCap(collectionIdentifier : key, collectionCap : collectionCap)\n\n        let items : [NFT] = []\n        for view in views {\n            let displayView = view.display\n            let externalURLView = view.externalURL\n            let collectionDataView = view.collectionData\n            let collectionDisplayView = view.collectionDisplay\n            let royaltyView = view.royalties\n            if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n                // Bad NFT. Skipping....\n                continue\n            }\n\n            items.append(\n                NFT(\n                    id: view.id,\n                    name : displayView!.name,\n                    description : displayView!.description,\n                    thumbnail : displayView!.thumbnail.uri(),\n                    externalURL : externalURLView!.url,\n                    storagePath : collectionDataView!.storagePath,\n                    publicPath : collectionDataView!.publicPath,\n                    privatePath : collectionDataView!.providerPath,\n                    publicLinkedType : collectionDataView!.publicLinkedType,\n                    privateLinkedType : collectionDataView!.providerLinkedType,\n                    collectionName : collectionDisplayView!.name,\n                    collectionDescription : collectionDisplayView!.description,\n                    collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n                    collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n                    collectionExternalURL : collectionDisplayView!.externalURL.url,\n                    royalties : royaltyView!.getRoyalties()\n                )\n            )\n        }\n        data[key] = items\n    }\n    return data\n}\n","get_examplenft_collection_length":"import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\n\npub fun main(address: Address): Int {\n    let account = getAccount(address)\n\n    let collectionRef = account\n        .getCapability(ExampleNFT.CollectionPublicPath)\n        .borrow<&{NonFungibleToken.CollectionPublic}>()\n        ?? panic(\"Could not borrow capability from public collection\")\n    \n    return collectionRef.getIDs().length\n}","get_examplenft_type":"import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\n\npub fun main(): String {\n    return Type<@ExampleNFT.NFT>().identifier\n}","get_nft_and_views_in_account":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTRetrieval from 0xNFTRetrieval\n\n\npub struct NFTCollectionData {\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n\n    init(\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n    ) {\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n    }\n}\n\n\npub struct NFT {\n    pub let id : UInt64\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n    pub let externalURL : String\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : String\n    pub let collectionBannerImage : String\n    pub let collectionExternalURL : String\n    pub let allViews :  {String: AnyStruct}?\n    pub let royalties: [MetadataViews.Royalty]\n\n    init(\n            id: UInt64,\n            name : String,\n            description : String,\n            thumbnail : String,\n            externalURL : String,\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n            collectionName : String,\n            collectionDescription : String,\n            collectionSquareImage : String,\n            collectionBannerImage : String,\n            collectionExternalURL : String,\n            allViews : {String: AnyStruct}?,\n            royalties : [MetadataViews.Royalty]\n    ) {\n        self.id = id\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n        self.externalURL = externalURL\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.collectionExternalURL = collectionExternalURL\n        self.allViews = allViews\n        self.royalties = royalties\n    }\n}\n\n pub fun getAllMetadataViewsFromCap(tokenID: UInt64, collectionIdentifier: String, collectionCap : Capability<&AnyResource{MetadataViews.ResolverCollection}>) : {String: AnyStruct} {\n        pre {\n            NFTCatalog.getCatalog()[collectionIdentifier] != nil : \"Invalid collection identifier\"\n        }\n        let catalog = NFTCatalog.getCatalog()\n        let items : {String: AnyStruct} = {}\n        let value = catalog[collectionIdentifier]!\n\n        // Check if we have multiple collections for the NFT type...\n        let hasMultipleCollections = false\n    \n        if collectionCap.check() {\n            let collectionRef = collectionCap.borrow()!\n\n            let nftResolver = collectionRef.borrowViewResolver(id: tokenID)\n            let supportedNftViewTypes = nftResolver.getViews()\n            for supportedViewType in supportedNftViewTypes {\n                if let view = nftResolver.resolveView(supportedViewType) {\n                    if !hasMultipleCollections {\n                        items.insert(key : supportedViewType.identifier, view)\n                    } else if MetadataViews.getDisplay(nftResolver)!.name == value.collectionDisplay.name {\n                        items.insert(key : supportedViewType.identifier, view)\n                    }\n                }\n            }\n        \n        }\n        return items\n    }\n\npub fun main(ownerAddress: Address, collectionIdentifier : String, tokenID: UInt64) : NFT? {\n        let catalog = NFTCatalog.getCatalog()\n\n        assert(catalog.containsKey(collectionIdentifier), message: \"Invalid Collection\")\n        \n        let account = getAuthAccount(ownerAddress)\n        \n        let value = catalog[collectionIdentifier]!\n        let tempPathStr = \"catalog\".concat(collectionIdentifier)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: value.collectionData.storagePath\n        )\n        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n        assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n        \n        let allViews = getAllMetadataViewsFromCap(tokenID: tokenID, collectionIdentifier : collectionIdentifier, collectionCap : collectionCap)\n        let nftCollectionDisplayView = allViews[Type<MetadataViews.NFTCollectionData>().identifier] as! MetadataViews.NFTCollectionData?\n        let collectionDataView = NFTCollectionData(\n                    storagePath : nftCollectionDisplayView!.storagePath,\n                    publicPath : nftCollectionDisplayView!.publicPath,\n                    privatePath : nftCollectionDisplayView!.providerPath,\n                    publicLinkedType : nftCollectionDisplayView!.publicLinkedType,\n                    privateLinkedType : nftCollectionDisplayView!.providerLinkedType,\n        )\n        \n        allViews.insert(key: Type<MetadataViews.NFTCollectionData>().identifier, collectionDataView)\n\n        let views = NFTRetrieval.getNFTViewsFromCap(collectionIdentifier : collectionIdentifier, collectionCap : collectionCap)\n        \n        for view in views {\n            if view.id == tokenID {\n                let displayView = view.display\n                let externalURLView = view.externalURL\n                let collectionDataView = view.collectionData\n                let collectionDisplayView = view.collectionDisplay\n                let royaltyView = view.royalties\n                if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n                    // Bad NFT. Skipping....\n                    return nil\n                }\n                return NFT(\n                    id: view.id,\n                    name : displayView!.name,\n                    description : displayView!.description,\n                    thumbnail : displayView!.thumbnail.uri(),\n                    externalURL : externalURLView!.url,\n                    storagePath : collectionDataView!.storagePath,\n                    publicPath : collectionDataView!.publicPath,\n                    privatePath : collectionDataView!.providerPath,\n                    publicLinkedType : collectionDataView!.publicLinkedType,\n                    privateLinkedType : collectionDataView!.providerLinkedType,\n                    collectionName : collectionDisplayView!.name,\n                    collectionDescription : collectionDisplayView!.description,\n                    collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n                    collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n                    collectionExternalURL : collectionDisplayView!.externalURL.url,\n                    allViews : allViews,\n                    royalties : royaltyView!.getRoyalties()\n                )\n            }\n        }\n        \n        panic(\"Invalid Token ID\")\n}\n","get_nft_catalog":"import NFTCatalog from 0xNFTCatalog\n\npub fun main(batch : [UInt64]?): {String : NFTCatalog.NFTCatalogMetadata} {\n    if batch == nil {\n        return NFTCatalog.getCatalog()\n    }\n    let catalog = NFTCatalog.getCatalog()\n    let catalogIDs = catalog.keys\n    var data : {String : NFTCatalog.NFTCatalogMetadata} = {}\n    var i = batch![0]\n    while i < batch![1] {\n        data.insert(key: catalogIDs[i], catalog[catalogIDs[i]]!)\n        i = i + 1\n    }\n    return data\n}\n ","get_nft_catalog_count":"import NFTCatalog from 0xNFTCatalog\n\npub fun main(): Int {\n    let catalog = NFTCatalog.getCatalog()\n    let catalogIDs = catalog.keys\n    return catalogIDs.length\n}","get_nft_catalog_proposals":"import NFTCatalog from 0xNFTCatalog\n\npub fun main(batch: [UInt64]?): {UInt64 : NFTCatalog.NFTCatalogProposal} {\n    if batch == nil {\n        return NFTCatalog.getCatalogProposals()\n    }\n    let proposals = NFTCatalog.getCatalogProposals()\n    let proposalIDs = proposals.keys\n    var data : {UInt64 : NFTCatalog.NFTCatalogProposal}  = {}\n    var i = batch![0]\n    while i < batch![1] {\n        data.insert(key: proposalIDs[i], proposals[proposalIDs[i]]!)\n        i = i + 1\n    }\n\n    return data\n}","get_nft_catalog_proposals_count":"import NFTCatalog from 0xNFTCatalog\n\npub fun main(): Int {\n    let proposals = NFTCatalog.getCatalogProposals()\n    let proposalIDs = proposals.keys\n    return proposalIDs.length\n}","get_nft_collections_for_nft_type":"import NFTCatalog from 0xNFTCatalog\n\npub fun main(nftTypeIdentifer: String): {String : Bool}? {\n    return NFTCatalog.getCollectionsForType(nftTypeIdentifier: CompositeType(nftTypeIdentifer)!.identifier)\n}","get_nft_ids_in_account":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTRetrieval from 0xNFTRetrieval\n\npub fun main(ownerAddress: Address) : {String : [UInt64]} {\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n\n    let items : {String : [UInt64]} = {}\n\n    for key in catalog.keys {\n        let value = catalog[key]!\n        let tempPathStr = \"catalogIDs\".concat(key)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: value.collectionData.storagePath\n        )\n\n        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n        if !collectionCap.check() {\n            continue\n        }\n\n        let ids = NFTRetrieval.getNFTIDsFromCap(collectionIdentifier : key, collectionCap : collectionCap)\n\n        if ids.length > 0 {\n            items[key] = ids\n        }\n    }\n    return items\n\n}","get_nft_in_account":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct NFT {\n    pub let id : UInt64\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n    pub let externalURL : String\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : String\n    pub let collectionBannerImage : String\n    pub let collectionExternalURL : String\n    pub let royalties: [MetadataViews.Royalty]\n\n    init(\n            id: UInt64,\n            name : String,\n            description : String,\n            thumbnail : String,\n            externalURL : String,\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n            collectionName : String,\n            collectionDescription : String,\n            collectionSquareImage : String,\n            collectionBannerImage : String,\n            collectionExternalURL : String,\n            royalties : [MetadataViews.Royalty]\n    ) {\n        self.id = id\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n        self.externalURL = externalURL\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.collectionExternalURL = collectionExternalURL\n        self.royalties = royalties\n    }\n}\n\npub fun main(ownerAddress: Address, collectionIdentifier : String, tokenID: UInt64) : NFT? {\n        let catalog = NFTCatalog.getCatalog()\n\n        assert(catalog.containsKey(collectionIdentifier), message: \"Invalid Collection\")\n        \n        let account = getAuthAccount(ownerAddress)\n        \n        let value = catalog[collectionIdentifier]!\n        let tempPathStr = \"catalog\".concat(collectionIdentifier)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: value.collectionData.storagePath\n        )\n        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n        assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n        let views = NFTRetrieval.getNFTViewsFromCap(collectionIdentifier : collectionIdentifier, collectionCap : collectionCap)\n        \n        for view in views {\n            if view.id == tokenID {\n                let displayView = view.display\n                let externalURLView = view.externalURL\n                let collectionDataView = view.collectionData\n                let collectionDisplayView = view.collectionDisplay\n                let royaltyView = view.royalties\n                if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n                    // Bad NFT. Skipping....\n                    return nil\n                }\n                return NFT(\n                    id: view.id,\n                    name : displayView!.name,\n                    description : displayView!.description,\n                    thumbnail : displayView!.thumbnail.uri(),\n                    externalURL : externalURLView!.url,\n                    storagePath : collectionDataView!.storagePath,\n                    publicPath : collectionDataView!.publicPath,\n                    privatePath : collectionDataView!.providerPath,\n                    publicLinkedType : collectionDataView!.publicLinkedType,\n                    privateLinkedType : collectionDataView!.providerLinkedType,\n                    collectionName : collectionDisplayView!.name,\n                    collectionDescription : collectionDisplayView!.description,\n                    collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n                    collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n                    collectionExternalURL : collectionDisplayView!.externalURL.url,\n                    royalties : royaltyView!.getRoyalties()\n                )\n            }\n        }\n        panic(\"Invalid Token ID\")\n}","get_nft_in_account_from_path":"import MetadataViews from 0xMetadataViews\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct DisplayView {\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n\n    init (\n        name : String,\n        description : String,\n        thumbnail : String\n    ) {\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n    }\n}\n\npub struct ExternalURLView {\n    pub let externalURL : String\n\n    init (\n        externalURL : String\n    ) {\n        self.externalURL = externalURL\n    }\n}\n\npub struct NFTCollectionDataView {\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n\n    init (\n        storagePath : StoragePath,\n        publicPath : PublicPath,\n        privatePath : PrivatePath,\n        publicLinkedType : Type,\n        privateLinkedType : Type,\n    ) {\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n    }\n}\n\npub struct NFTCollectionDisplayView {\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : MetadataViews.Media\n    pub let collectionBannerImage : MetadataViews.Media\n    pub let externalURL : String\n    pub let socials : {String: MetadataViews.ExternalURL}\n\n    init (\n        collectionName : String,\n        collectionDescription : String,\n        collectionSquareImage : MetadataViews.Media,\n        collectionBannerImage : MetadataViews.Media,\n        externalURL : String,\n        socials : {String: MetadataViews.ExternalURL}\n    ) {\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.externalURL = externalURL\n        self.socials = socials\n    }\n}\n\npub struct RoyaltiesView {\n    pub let royalties: [MetadataViews.Royalty]\n\n    init (\n        royalties : [MetadataViews.Royalty]\n    ) {\n        self.royalties = royalties\n    }\n}\n\npub struct NFT {\n    pub let id : UInt64\n    pub let display : DisplayView?\n    pub let externalURL : ExternalURLView?\n    pub let nftCollectionData : NFTCollectionDataView?\n    pub let nftCollectionDisplay : NFTCollectionDisplayView?\n    pub let royalties : RoyaltiesView?\n\n    init(\n            id: UInt64,\n            display : DisplayView?,\n            externalURL : ExternalURLView?,\n            nftCollectionData : NFTCollectionDataView?,\n            nftCollectionDisplay : NFTCollectionDisplayView?,\n            royalties : RoyaltiesView?\n    ) {\n        self.id = id\n        self.display = display\n        self.externalURL = externalURL\n        self.nftCollectionData = nftCollectionData\n        self.nftCollectionDisplay = nftCollectionDisplay\n        self.royalties = royalties\n}\n\npub fun getMapping() : {String : AnyStruct} {\n    return {\n        \"Id\" : self.id,\n        \"Display\" : self.display,\n        \"ExternalURL\" : self.externalURL,\n        \"NFTCollectionData\" : self.nftCollectionData,\n        \"NFTCollectionDisplay\" : self.nftCollectionDisplay,\n        \"Royalties\" : self.royalties\n    }\n}\n\n}\n\npub fun main(ownerAddress: Address, storagePathIdentifier: String, nftID: UInt64): {String : AnyStruct}    {\n    let owner = getAuthAccount(ownerAddress)\n    \n    let tempPathStr = \"getNFTsInAccountFromPathNFTCatalog\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    owner.link<&{MetadataViews.ResolverCollection}>(\n        tempPublicPath,\n        target: StoragePath(identifier : storagePathIdentifier)!\n    )\n\n    let collectionCap = owner.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n    assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n    let collection = collectionCap.borrow()!\n    assert(collection.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n\n    return getNFTData(nftID: nftID, collection: collection)\n}\n\n\npub fun getNFTData(nftID: UInt64, collection: &AnyResource{MetadataViews.ResolverCollection} ): {String : AnyStruct} {\n    let nftResolver = collection.borrowViewResolver(id: nftID)\n    let nftViews = MetadataViews.getNFTView(\n        id : nftID,\n        viewResolver: nftResolver\n    )\n\n    let displayView = nftViews.display\n    let externalURLView = nftViews.externalURL\n    let collectionDataView = nftViews.collectionData\n    let collectionDisplayView = nftViews.collectionDisplay\n    let royaltyView = nftViews.royalties\n\n    var display : DisplayView? = nil\n    if displayView != nil {\n        display = DisplayView(\n            name : displayView!.name,\n            description : displayView!.description,\n            thumbnail : displayView!.thumbnail.uri()\n        )\n    }\n\n    var externalURL : ExternalURLView? = nil\n    if externalURLView != nil {\n        externalURL = ExternalURLView(\n            externalURL : externalURLView!.url,\n        )\n    }\n\n    var nftCollectionData : NFTCollectionDataView? = nil\n    if collectionDataView != nil {\n        nftCollectionData = NFTCollectionDataView(\n            storagePath : collectionDataView!.storagePath,\n            publicPath : collectionDataView!.publicPath,\n            privatePath : collectionDataView!.providerPath,\n            publicLinkedType : collectionDataView!.publicLinkedType,\n            privateLinkedType : collectionDataView!.providerLinkedType,\n        )\n    }\n\n    var nftCollectionDisplay : NFTCollectionDisplayView? = nil\n    if collectionDisplayView != nil {\n        nftCollectionDisplay = NFTCollectionDisplayView(\n            collectionName : collectionDisplayView!.name,\n            collectionDescription : collectionDisplayView!.description,\n            collectionSquareImage : collectionDisplayView!.squareImage,\n            collectionBannerImage : collectionDisplayView!.bannerImage,\n            externalURL : collectionDisplayView!.externalURL.url,\n            socials : collectionDisplayView!.socials\n        )\n    }\n\n    var royalties : RoyaltiesView? = nil\n    if royaltyView != nil {\n        royalties = RoyaltiesView(\n            royalties : royaltyView!.getRoyalties()\n        )\n    }\n\n    return NFT(\n        id: nftID,\n        display : display,\n        externalURL : externalURL,\n        nftCollectionData : nftCollectionData,\n        nftCollectionDisplay : nftCollectionDisplay,\n        royalties : royalties\n    ).getMapping()\n}","get_nft_metadata_for_collection_identifier":"import NFTCatalog from 0xNFTCatalog\n\npub fun main(collectionIdentifier: String): NFTCatalog.NFTCatalogMetadata? {\n    return NFTCatalog.getCatalogEntry(collectionIdentifier: collectionIdentifier)\n}","get_nft_proposal_for_id":"import NFTCatalog from 0xNFTCatalog\n\npub fun main(proposalID: UInt64): NFTCatalog.NFTCatalogProposal? {\n    return NFTCatalog.getCatalogProposalEntry(proposalID: proposalID)\n}","get_nfts_count_in_account":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTRetrieval from 0xNFTRetrieval\n\npub fun main(ownerAddress: Address) : {String : Number} {\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n    let items : {String : Number} = {}\n\n    for key in catalog.keys {\n        let value = catalog[key]!\n        let tempPathStr = \"catalog\".concat(key)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: value.collectionData.storagePath\n        )\n        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n        if !collectionCap.check() {\n            continue\n        }\n        let count = NFTRetrieval.getNFTCountFromCap(collectionIdentifier : key, collectionCap : collectionCap)\n        if count != 0 {\n            items[key] = count\n        }\n    }\n\n    return items\n}","get_nfts_in_account":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct NFT {\n    pub let id : UInt64\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n    pub let externalURL : String\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : String\n    pub let collectionBannerImage : String\n    pub let collectionExternalURL : String\n    pub let royalties: [MetadataViews.Royalty]\n\n    init(\n            id: UInt64,\n            name : String,\n            description : String,\n            thumbnail : String,\n            externalURL : String,\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n            collectionName : String,\n            collectionDescription : String,\n            collectionSquareImage : String,\n            collectionBannerImage : String,\n            collectionExternalURL : String,\n            royalties : [MetadataViews.Royalty]\n    ) {\n        self.id = id\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n        self.externalURL = externalURL\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.collectionExternalURL = collectionExternalURL\n        self.royalties = royalties\n    }\n}\n\npub fun main(ownerAddress: Address, collectionIdentifiers: [String]) : { String : [NFT] }    {\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n    \n    let data : {String : [NFT] } = {}\n\n    for collectionIdentifier in collectionIdentifiers {\n        if catalog.containsKey(collectionIdentifier) {\n            let value = catalog[collectionIdentifier]!\n            let tempPathStr = \"catalog\".concat(collectionIdentifier)\n            let tempPublicPath = PublicPath(identifier: tempPathStr)!\n            account.link<&{MetadataViews.ResolverCollection}>(\n                tempPublicPath,\n                target: value.collectionData.storagePath\n            )\n            \n            let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n            if !collectionCap.check() {\n                continue\n            }\n            let views = NFTRetrieval.getNFTViewsFromCap(collectionIdentifier : collectionIdentifier, collectionCap : collectionCap)\n            \n            let items : [NFT] = []\n            \n            for view in views {\n                let displayView = view.display\n                let externalURLView = view.externalURL\n                let collectionDataView = view.collectionData\n                let collectionDisplayView = view.collectionDisplay\n                let royaltyView = view.royalties\n                if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n                    // Bad NFT. Skipping....\n                    continue\n                }\n\n                items.append(\n                    NFT(\n                        id: view.id,\n                        name : displayView!.name,\n                        description : displayView!.description,\n                        thumbnail : displayView!.thumbnail.uri(),\n                        externalURL : externalURLView!.url,\n                        storagePath : collectionDataView!.storagePath,\n                        publicPath : collectionDataView!.publicPath,\n                        privatePath : collectionDataView!.providerPath,\n                        publicLinkedType : collectionDataView!.publicLinkedType,\n                        privateLinkedType : collectionDataView!.providerLinkedType,\n                        collectionName : collectionDisplayView!.name,\n                        collectionDescription : collectionDisplayView!.description,\n                        collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n                        collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n                        collectionExternalURL : collectionDisplayView!.externalURL.url,\n                        royalties : royaltyView!.getRoyalties()\n                    )\n                )\n            }\n            \n            data[collectionIdentifier] = items\n        }\n    }\n\n    return data\n}","get_nfts_in_account_from_ids":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct NFT {\n    pub let id : UInt64\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n    pub let externalURL : String\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : String\n    pub let collectionBannerImage : String\n    pub let collectionExternalURL : String\n    pub let royalties: [MetadataViews.Royalty]\n\n    init(\n            id: UInt64,\n            name : String,\n            description : String,\n            thumbnail : String,\n            externalURL : String,\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n            collectionName : String,\n            collectionDescription : String,\n            collectionSquareImage : String,\n            collectionBannerImage : String,\n            collectionExternalURL : String,\n            royalties : [MetadataViews.Royalty]\n    ) {\n        self.id = id\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n        self.externalURL = externalURL\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.collectionExternalURL = collectionExternalURL\n        self.royalties = royalties\n    }\n}\n\npub fun main(ownerAddress: Address, collections: {String : [UInt64]}) : {String : [NFT] } {\n    let data : {String : [NFT] } = {}\n\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n    for collectionIdentifier in collections.keys {\n        if catalog.containsKey(collectionIdentifier) {\n            let value = catalog[collectionIdentifier]!\n            let tempPathStr = \"catalog\".concat(collectionIdentifier)\n            let tempPublicPath = PublicPath(identifier: tempPathStr)!\n            account.link<&{MetadataViews.ResolverCollection}>(\n                tempPublicPath,\n                target: value.collectionData.storagePath\n            )\n\n            let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n\n            if !collectionCap.check() {\n                return data\n            }\n\n            let views = NFTRetrieval.getNFTViewsFromIDs(collectionIdentifier : collectionIdentifier, ids: collections[collectionIdentifier]!, collectionCap : collectionCap)\n\n            let items : [NFT] = []\n\n            for view in views {\n                    let displayView = view.display\n                    let externalURLView = view.externalURL\n                    let collectionDataView = view.collectionData\n                    let collectionDisplayView = view.collectionDisplay\n                    let royaltyView = view.royalties\n                    if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n                        // Bad NFT. Skipping....\n                        continue\n                    }\n\n                    items.append(\n                        NFT(\n                            id: view.id,\n                            name : displayView!.name,\n                            description : displayView!.description,\n                            thumbnail : displayView!.thumbnail.uri(),\n                            externalURL : externalURLView!.url,\n                            storagePath : collectionDataView!.storagePath,\n                            publicPath : collectionDataView!.publicPath,\n                            privatePath : collectionDataView!.providerPath,\n                            publicLinkedType : collectionDataView!.publicLinkedType,\n                            privateLinkedType : collectionDataView!.providerLinkedType,\n                            collectionName : collectionDisplayView!.name,\n                            collectionDescription : collectionDisplayView!.description,\n                            collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n                            collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n                            collectionExternalURL : collectionDisplayView!.externalURL.url,\n                            royalties : royaltyView!.getRoyalties()\n                        )\n                    )\n                }\n\n                data[collectionIdentifier] = items\n        }\n    }\n\n\n    return data\n}","get_nfts_in_account_from_path":"import MetadataViews from 0xMetadataViews\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct DisplayView {\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n\n    init (\n        name : String,\n        description : String,\n        thumbnail : String\n    ) {\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n    }\n}\n\npub struct ExternalURLView {\n    pub let externalURL : String\n\n    init (\n        externalURL : String\n    ) {\n        self.externalURL = externalURL\n    }\n}\n\npub struct NFTCollectionDataView {\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n\n    init (\n        storagePath : StoragePath,\n        publicPath : PublicPath,\n        privatePath : PrivatePath,\n        publicLinkedType : Type,\n        privateLinkedType : Type,\n    ) {\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n    }\n}\n\npub struct NFTCollectionDisplayView {\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : MetadataViews.Media\n    pub let collectionBannerImage : MetadataViews.Media\n    pub let externalURL : String\n    pub let socials : {String: MetadataViews.ExternalURL}\n\n    init (\n        collectionName : String,\n        collectionDescription : String,\n        collectionSquareImage : MetadataViews.Media,\n        collectionBannerImage : MetadataViews.Media,\n        externalURL : String,\n        socials : {String: MetadataViews.ExternalURL}\n    ) {\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.externalURL = externalURL\n        self.socials = socials\n    }\n}\n\npub struct RoyaltiesView {\n    pub let royalties: [MetadataViews.Royalty]\n\n    init (\n        royalties : [MetadataViews.Royalty]\n    ) {\n        self.royalties = royalties\n    }\n}\n\npub struct NFT {\n    pub let id : UInt64\n    pub let display : DisplayView?\n    pub let externalURL : ExternalURLView?\n    pub let nftCollectionData : NFTCollectionDataView?\n    pub let nftCollectionDisplay : NFTCollectionDisplayView?\n    pub let royalties : RoyaltiesView?\n\n    init(\n            id: UInt64,\n            display : DisplayView?,\n            externalURL : ExternalURLView?,\n            nftCollectionData : NFTCollectionDataView?,\n            nftCollectionDisplay : NFTCollectionDisplayView?,\n            royalties : RoyaltiesView?\n    ) {\n        self.id = id\n        self.display = display\n        self.externalURL = externalURL\n        self.nftCollectionData = nftCollectionData\n        self.nftCollectionDisplay = nftCollectionDisplay\n        self.royalties = royalties\n}\n\npub fun getMapping() : {String : AnyStruct} {\n    return {\n        \"Id\" : self.id,\n        \"Display\" : self.display,\n        \"ExternalURL\" : self.externalURL,\n        \"NFTCollectionData\" : self.nftCollectionData,\n        \"NFTCollectionDisplay\" : self.nftCollectionDisplay,\n        \"Royalties\" : self.royalties\n    }\n}\n\n}\n\npub fun main(ownerAddress: Address, storagePathIdentifier: String): [{String : AnyStruct}]    {\n    let owner = getAuthAccount(ownerAddress)\n    \n    let tempPathStr = \"getNFTsInAccountFromPathNFTCatalog\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    owner.link<&{MetadataViews.ResolverCollection}>(\n        tempPublicPath,\n        target: StoragePath(identifier : storagePathIdentifier)!\n    )\n\n    let collectionCap = owner.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n    assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n    let collection = collectionCap.borrow()!\n    assert(collection.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n\n    let data : [{String : AnyStruct}] = []\n\n    for nftID in collection.getIDs() {\n        data.append(getNFTData(nftID: nftID, collection: collection))\n    }\n\n    return data\n}\n\n\npub fun getNFTData(nftID: UInt64, collection: &AnyResource{MetadataViews.ResolverCollection} ): {String : AnyStruct} {\n    let nftResolver = collection.borrowViewResolver(id: nftID)\n    let nftViews = MetadataViews.getNFTView(\n        id : nftID,\n        viewResolver: nftResolver\n    )\n\n    let displayView = nftViews.display\n    let externalURLView = nftViews.externalURL\n    let collectionDataView = nftViews.collectionData\n    let collectionDisplayView = nftViews.collectionDisplay\n    let royaltyView = nftViews.royalties\n\n    var display : DisplayView? = nil\n    if displayView != nil {\n        display = DisplayView(\n            name : displayView!.name,\n            description : displayView!.description,\n            thumbnail : displayView!.thumbnail.uri()\n        )\n    }\n\n    var externalURL : ExternalURLView? = nil\n    if externalURLView != nil {\n        externalURL = ExternalURLView(\n            externalURL : externalURLView!.url,\n        )\n    }\n\n    var nftCollectionData : NFTCollectionDataView? = nil\n    if collectionDataView != nil {\n        nftCollectionData = NFTCollectionDataView(\n            storagePath : collectionDataView!.storagePath,\n            publicPath : collectionDataView!.publicPath,\n            privatePath : collectionDataView!.providerPath,\n            publicLinkedType : collectionDataView!.publicLinkedType,\n            privateLinkedType : collectionDataView!.providerLinkedType,\n        )\n    }\n\n    var nftCollectionDisplay : NFTCollectionDisplayView? = nil\n    if collectionDisplayView != nil {\n        nftCollectionDisplay = NFTCollectionDisplayView(\n            collectionName : collectionDisplayView!.name,\n            collectionDescription : collectionDisplayView!.description,\n            collectionSquareImage : collectionDisplayView!.squareImage,\n            collectionBannerImage : collectionDisplayView!.bannerImage,\n            externalURL : collectionDisplayView!.externalURL.url,\n            socials : collectionDisplayView!.socials\n        )\n    }\n\n    var royalties : RoyaltiesView? = nil\n    if royaltyView != nil {\n        royalties = RoyaltiesView(\n            royalties : royaltyView!.getRoyalties()\n        )\n    }\n\n    return NFT(\n        id: nftID,\n        display : display,\n        externalURL : externalURL,\n        nftCollectionData : nftCollectionData,\n        nftCollectionDisplay : nftCollectionDisplay,\n        royalties : royalties\n    ).getMapping()\n}","get_supported_generated_scripts":"import TransactionGeneration from 0xTransactionGeneration\n\npub fun main() : [String] {\n    return TransactionGeneration.getSupportedScripts()\n}","get_supported_generated_transactions":"import TransactionGeneration from 0xTransactionGeneration\n\npub fun main() : [String] {\n    return TransactionGeneration.getSupportedTx()\n}","has_admin_proxy":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\npub fun main(ownerAddress: Address) : Bool {\n    let owner = getAccount(ownerAddress)\n    let proxyCap = owner.getCapability<&NFTCatalogAdmin.AdminProxy{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath)\n    return proxyCap.check()\n}","is_catalog_admin":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\npub fun main(ownerAddress: Address) : Bool {\n    let owner = getAccount(ownerAddress)\n    let proxyCap = owner.getCapability<&NFTCatalogAdmin.AdminProxy{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath)\n    if !proxyCap.check() {\n        return false\n    }\n    let proxyRef = proxyCap.borrow()!\n    return proxyRef.hasCapability()\n}"},"vars":{"emulator":{"0xNonFungibleToken":"0xf8d6e0586b0a20c7","0xMetadataViews":"0xf8d6e0586b0a20c7","0xFungibleToken":"0xee82856bf20e2aa6","0xFlowToken":"0x0ae53cb6e3f42a79","0xDapperUtilityCoin":"0xf8d6e0586b0a20c7","0xFlowUtilityToken":"0xf8d6e0586b0a20c7","0xNFTStorefrontV2":"0xf8d6e0586b0a20c7","0xTokenForwarding":"0xf8d6e0586b0a20c7","0xExampleNFT":"0xf8d6e0586b0a20c7","0xNonStandardNFT":"0xf8d6e0586b0a20c7","0xNFTCatalog":"0xf8d6e0586b0a20c7","0xNFTCatalogAdmin":"0xf8d6e0586b0a20c7","0xNFTRetrieval":"0xf8d6e0586b0a20c7","0xTransactionGenerationUtils":"0xf8d6e0586b0a20c7","0xTransactionGeneration":"0xf8d6e0586b0a20c7","0xTransactionTemplates":"0xf8d6e0586b0a20c7","0xStringUtils":"0xf8d6e0586b0a20c7","0xArrayUtils":"0xf8d6e0586b0a20c7"},"testnet":{"0xNonFungibleToken":"0x631e88ae7f1d7c20","0xMetadataViews":"0x631e88ae7f1d7c20","0xFungibleToken":"0x9a0766d93b6608b7","0xFlowToken":"0x7e60df042a9c0868","0xDapperUtilityCoin":"0x82ec283f88a62e65","0xFlowUtilityToken":"0x82ec283f88a62e65","0xNFTStorefrontV2":"0x2d55b98eb200daef","0xTokenForwarding":"0x51ea0e37c27a1f1a","0xExampleNFT":null,"0xNonStandardNFT":null,"0xNFTCatalog":"0x324c34e1c517e4db","0xNFTCatalogAdmin":"0x324c34e1c517e4db","0xNFTRetrieval":"0x324c34e1c517e4db","0xTransactionGenerationUtils":"0x44051d81c4720882","0xTransactionGeneration":"0x44051d81c4720882","0xTransactionTemplates":"0x44051d81c4720882","0xStringUtils":"0x44051d81c4720882","0xArrayUtils":"0x44051d81c4720882"},"mainnet":{"0xNonFungibleToken":"0x1d7e57aa55817448","0xMetadataViews":"0x1d7e57aa55817448","0xFungibleToken":"0xf233dcee88fe0abe","0xFlowToken":"0x1654653399040a61","0xDapperUtilityCoin":"0xead892083b3e2c6c","0xFlowUtilityToken":"0xead892083b3e2c6c","0xNFTStorefrontV2":"0x4eb8a10cb9f87357","0xTokenForwarding":"0xe544175ee0461c4b","0xExampleNFT":null,"0xNonStandardNFT":null,"0xNFTCatalog":"0x49a7cda3a1eecc29","0xNFTCatalogAdmin":"0x49a7cda3a1eecc29","0xNFTRetrieval":"0x49a7cda3a1eecc29","0xTransactionGenerationUtils":"0xe52522745adf5c34","0xTransactionGeneration":"0xe52522745adf5c34","0xTransactionTemplates":"0xe52522745adf5c34","0xStringUtils":"0xe52522745adf5c34","0xArrayUtils":"0xe52522745adf5c34"}}}