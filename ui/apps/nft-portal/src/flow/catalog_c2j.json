{
  "transactions": {
    "add_to_nft_catalog": "import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(\n    collectionIdentifier : String,\n    contractName: String,\n    contractAddress: Address,\n    nftTypeIdentifer: String,\n    addressWithNFT: Address,\n    nftID: UInt64,\n    publicPathIdentifier: String\n) {\n    let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n    prepare(acct: AuthAccount) {\n        self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n    }\n\n    execute {\n        let nftAccount = getAccount(addressWithNFT)\n        let pubPath = PublicPath(identifier: publicPathIdentifier)!\n        let collectionCap = nftAccount.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(pubPath)\n        assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n        let collectionRef = collectionCap.borrow()!\n        assert(collectionRef.getIDs().length > 0, message: \"No NFTs exist in this collection.\")\n        let nftResolver = collectionRef.borrowViewResolver(id: nftID)\n        \n        let metadataCollectionData = nftResolver.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData\n        \n        let collectionData = NFTCatalog.NFTCollectionData(\n            storagePath: metadataCollectionData.storagePath,\n            publicPath: metadataCollectionData.publicPath,\n            privatePath: metadataCollectionData.providerPath,\n            publicLinkedType : metadataCollectionData.publicLinkedType,\n            privateLinkedType : metadataCollectionData.providerLinkedType\n        )\n\n        let collectionDisplay = nftResolver.resolveView(Type<MetadataViews.NFTCollectionDisplay>())! as! MetadataViews.NFTCollectionDisplay\n\n        let catalogData = NFTCatalog.NFTCatalogMetadata(\n            contractName: contractName,\n            contractAddress: contractAddress,\n            nftType: CompositeType(nftTypeIdentifer)!,\n            collectionData: collectionData,\n            collectionDisplay : collectionDisplay\n        )\n        \n        self.adminProxyResource.getCapability()!.borrow()!.addCatalogEntry(collectionIdentifier : collectionIdentifier, metadata : catalogData)\n    }\n}",
    "add_to_nft_catalog_admin": "import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(\n    collectionIdentifier : String,\n    contractName: String,\n    contractAddress: Address,\n    nftTypeIdentifer: String,\n    addressWithNFT: Address,\n    nftID: UInt64,\n    publicPathIdentifier: String\n) {\n    \n    let adminResource: &NFTCatalogAdmin.Admin\n    \n    prepare(acct: AuthAccount) {\n        self.adminResource = acct.borrow<&NFTCatalogAdmin.Admin>(from: NFTCatalogAdmin.AdminStoragePath)!\n    }\n    \n    execute {\n        let nftAccount = getAccount(addressWithNFT)\n        let pubPath = PublicPath(identifier: publicPathIdentifier)!\n        let collectionCap = nftAccount.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(pubPath)\n        assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n        let collectionRef = collectionCap.borrow()!\n        assert(collectionRef.getIDs().length > 0, message: \"No NFTs exist in this collection.\")\n        let nftResolver = collectionRef.borrowViewResolver(id: nftID)\n        \n        let metadataCollectionData = nftResolver.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData\n        \n        let collectionData = NFTCatalog.NFTCollectionData(\n            storagePath: metadataCollectionData.storagePath,\n            publicPath: metadataCollectionData.publicPath,\n            privatePath: metadataCollectionData.providerPath,\n            publicLinkedType : metadataCollectionData.publicLinkedType,\n            privateLinkedType : metadataCollectionData.providerLinkedType\n        )\n\n        let collectionDisplay = nftResolver.resolveView(Type<MetadataViews.NFTCollectionDisplay>())! as! MetadataViews.NFTCollectionDisplay\n\n        let catalogData = NFTCatalog.NFTCatalogMetadata(\n            contractName: contractName,\n            contractAddress: contractAddress,\n            nftType: CompositeType(nftTypeIdentifer)!,\n            collectionData: collectionData,\n            collectionDisplay : collectionDisplay\n        )\n\n        self.adminResource.addCatalogEntry(collectionIdentifier : collectionIdentifier, metadata : catalogData)\n    }\n}",
    "approve_nft_catalog_proposal": "import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(proposalID : UInt64) {\n    let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n    prepare(acct: AuthAccount) {\n        self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n    }\n\n    execute {\n        self.adminProxyResource.getCapability()!.borrow()!.approveCatalogProposal(proposalID : proposalID)\n    }\n}",
    "mint_example_nft": "import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\nimport MetadataViews from 0xMetadataViews\nimport FungibleToken from 0xFungibleToken\n\n// This script uses the NFTMinter resource to mint a new NFT\n// It must be run with the account that has the minter resource\n// stored in /storage/NFTMinter\n\ntransaction(\n    recipient: Address,\n    name: String,\n    description: String,\n    thumbnail: String,\n    cuts: [UFix64],\n    royaltyDescriptions: [String],\n    royaltyBeneficiaries: [Address]\n) {\n\n    // local variable for storing the minter reference\n    let minter: &ExampleNFT.NFTMinter\n\n    let royalties: [MetadataViews.Royalty]\n\n\n    prepare(signer: AuthAccount) {\n        // borrow a reference to the NFTMinter resource in storage\n        self.minter = signer.borrow<&ExampleNFT.NFTMinter>(from: ExampleNFT.MinterStoragePath)\n            ?? panic(\"Could not borrow a reference to the NFT minter\")\n        \n        // creating the royalty details\n        var count = 0\n        self.royalties = []\n        while royaltyBeneficiaries.length > count {\n            let beneficiary = royaltyBeneficiaries[count]\n            let beneficiaryCapability = getAccount(beneficiary)\n            .getCapability<&{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())\n\n            // Make sure the royalty capability is valid before minting the NFT\n            if !beneficiaryCapability.check() { panic(\"Beneficiary capability is not valid!\") }\n\n            self.royalties.append(\n                MetadataViews.Royalty(\n                    receiver: beneficiaryCapability,\n                    cut: cuts[count],\n                    description: royaltyDescriptions[count]\n                )\n            )\n            count = count + 1\n        }\n    }\n\n    pre {\n        cuts.length == royaltyDescriptions.length && cuts.length == royaltyBeneficiaries.length: \"Array length should be equal for royalty related details\"\n    }\n\n    execute {\n        // Borrow the recipient's public NFT collection reference\n        let receiver = getAccount(recipient)\n            .getCapability(ExampleNFT.CollectionPublicPath)\n            .borrow<&{NonFungibleToken.CollectionPublic}>()\n            ?? panic(\"Could not get receiver reference to the NFT Collection\")\n\n        // Mint the NFT and deposit it to the recipient's collection\n        self.minter.mintNFT(\n            recipient: receiver,\n            name: name,\n            description: description,\n            thumbnail: thumbnail,\n            royalties: self.royalties\n        )\n    }\n}\n ",
    "propose_nft_to_catalog": "import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\n\ntransaction(\n    collectionIdentifier : String,\n    contractName: String,\n    contractAddress: Address,\n    nftTypeIdentifer: String,\n    storagePathIdentifier: String,\n    publicPathIdentifier: String,\n    privatePathIdentifier: String,\n    publicLinkedTypeIdentifier : String,\n    publicLinkedTypeRestrictions : [String],\n    privateLinkedTypeIdentifier : String,\n    privateLinkedTypeRestrictions : [String],\n    collectionName : String,\n    collectionDescription: String,\n    externalURL : String,\n    squareImageMediaURL : String,\n    squareImageMediaType : String,\n    bannerImageMediaURL : String,\n    bannerImageMediaType : String,\n    socials: {String : String},\n    message: String\n) {\n\n    let nftCatalogProposalResourceRef : &NFTCatalog.NFTCatalogProposalManager\n    \n    prepare(acct: AuthAccount) {\n        \n        if acct.borrow<&NFTCatalog.NFTCatalogProposalManager>(from: NFTCatalog.ProposalManagerStoragePath) == nil {\n             let proposalManager <- NFTCatalog.createNFTCatalogProposalManager()\n             acct.save(<-proposalManager, to: NFTCatalog.ProposalManagerStoragePath)\n             acct.link<&NFTCatalog.NFTCatalogProposalManager{NFTCatalog.NFTCatalogProposalManagerPublic}>(NFTCatalog.ProposalManagerPublicPath, target: NFTCatalog.ProposalManagerStoragePath)\n        }\n\n        self.nftCatalogProposalResourceRef = acct.borrow<&NFTCatalog.NFTCatalogProposalManager>(from: NFTCatalog.ProposalManagerStoragePath)!\n    }\n    \n    execute {\n        \n        let collectionData = NFTCatalog.NFTCollectionData(\n            storagePath: StoragePath(identifier: storagePathIdentifier)!,\n            publicPath: PublicPath(identifier : publicPathIdentifier)!,\n            privatePath: PrivatePath(identifier: privatePathIdentifier)!,\n            publicLinkedType : RestrictedType(identifier : publicLinkedTypeIdentifier, restrictions: publicLinkedTypeRestrictions)!,\n            privateLinkedType : RestrictedType(identifier : privateLinkedTypeIdentifier, restrictions: privateLinkedTypeRestrictions)!\n        )\n\n        let squareMedia = MetadataViews.Media(\n                        file: MetadataViews.HTTPFile(\n                            url: squareImageMediaURL\n                        ),\n                        mediaType: squareImageMediaURL\n                    )\n        \n        let bannerMedia = MetadataViews.Media(\n                        file: MetadataViews.HTTPFile(\n                            url: bannerImageMediaURL\n                        ),\n                        mediaType: bannerImageMediaURL\n                    )\n\n        let socialsStruct : {String : MetadataViews.ExternalURL} = {}\n        for key in socials.keys {\n            socialsStruct[key] =  MetadataViews.ExternalURL(socials[key]!)\n        }\n        \n        let collectionDisplay = MetadataViews.NFTCollectionDisplay(\n            name: collectionName,\n            description: collectionDescription,\n            externalURL: MetadataViews.ExternalURL(externalURL),\n            squareImage: squareMedia,\n            bannerImage: bannerMedia,\n            socials: socialsStruct\n        )\n\n        let catalogData = NFTCatalog.NFTCatalogMetadata(\n            contractName: contractName,\n            contractAddress: contractAddress,\n            nftType: CompositeType(nftTypeIdentifer)!,\n            collectionData: collectionData,\n            collectionDisplay : collectionDisplay\n        )\n\n        self.nftCatalogProposalResourceRef.setCurrentProposalEntry(identifier : collectionIdentifier)\n\n        NFTCatalog.proposeNFTMetadata(collectionIdentifier : collectionIdentifier, metadata : catalogData, message: message, proposer: self.nftCatalogProposalResourceRef.owner!.address)\n\n        self.nftCatalogProposalResourceRef.setCurrentProposalEntry(identifier : nil)\n    }\n}",
    "reject_nft_catalog_proposal": "import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(proposalID : UInt64) {\n    let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n    prepare(acct: AuthAccount) {\n        self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n    }\n\n    execute {\n        self.adminProxyResource.getCapability()!.borrow()!.rejectCatalogProposal(proposalID : proposalID)\n    }\n}",
    "remove_from_nft_catalog": "import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(\n    collectionIdentifier : String\n) {\n    let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n    prepare(acct: AuthAccount) {\n        self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n    }\n\n    execute {     \n        self.adminProxyResource.getCapability()!.borrow()!.removeCatalogEntry(collectionIdentifier : collectionIdentifier)\n    }\n}",
    "remove_nft_catalog_proposal": "import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(proposalID : UInt64) {\n    let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n    prepare(acct: AuthAccount) {\n        self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n    }\n\n    execute {\n        self.adminProxyResource.getCapability()!.borrow()!.removeCatalogProposal(proposalID : proposalID)\n    }\n}",
    "send_admin_capability_to_proxy": "import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(proxyAddress: Address) {\n    let adminCap : Capability<&NFTCatalogAdmin.Admin>\n    \n    prepare(acct: AuthAccount) {\n        self.adminCap = acct.getCapability<&NFTCatalogAdmin.Admin>(NFTCatalogAdmin.AdminPrivatePath)\n    }\n\n    execute {\n        let owner = getAccount(proxyAddress)\n        let proxy = owner.getCapability<&NFTCatalogAdmin.AdminProxy{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath)\n            .borrow() ?? panic(\"Could not borrow Admin Proxy\")\n        \n        proxy.addCapability(capability : self.adminCap)\n    }\n}",
    "setup_examplenft_collection": "import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\nimport MetadataViews from 0xMetadataViews\n\n// This transaction is what an account would run\n// to set itself up to receive NFTs\n\ntransaction {\n\n    prepare(signer: AuthAccount) {\n        // Return early if the account already has a collection\n        if signer.borrow<&ExampleNFT.Collection>(from: ExampleNFT.CollectionStoragePath) != nil {\n            return\n        }\n\n        // Create a new empty collection\n        let collection <- ExampleNFT.createEmptyCollection()\n\n        // save it to the account\n        signer.save(<-collection, to: ExampleNFT.CollectionStoragePath)\n\n        // create a public capability for the collection\n        signer.link<&{NonFungibleToken.CollectionPublic, ExampleNFT.ExampleNFTCollectionPublic, MetadataViews.ResolverCollection}>(\n            ExampleNFT.CollectionPublicPath,\n            target: ExampleNFT.CollectionStoragePath\n        )\n    }\n}",
    "setup_nft_catalog_admin_proxy": "import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction() {\n    \n    prepare(acct: AuthAccount) {\n        acct.save(<- NFTCatalogAdmin.createAdminProxy(), to: NFTCatalogAdmin.AdminProxyStoragePath)\n        acct.link<&NFTCatalogAdmin.AdminProxy{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath, target: NFTCatalogAdmin.AdminProxyStoragePath)\n    }\n}",
    "transfer_examplenft": "import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\n\n// This transaction is for transferring and NFT from\n// one account to another\n\ntransaction(recipient: Address, withdrawID: UInt64) {\n\n    prepare(signer: AuthAccount) {\n        // get the recipients public account object\n        let recipient = getAccount(recipient)\n\n        // borrow a reference to the signer's NFT collection\n        let collectionRef = signer\n            .borrow<&ExampleNFT.Collection>(from: ExampleNFT.CollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to the owner's collection\")\n\n        // borrow a public reference to the receivers collection\n        let depositRef = recipient\n            .getCapability(ExampleNFT.CollectionPublicPath)\n            .borrow<&{NonFungibleToken.CollectionPublic}>()\n            ?? panic(\"Could not borrow a reference to the receiver's collection\")\n\n        // withdraw the NFT from the owner's collection\n        let nft <- collectionRef.withdraw(withdrawID: withdrawID)\n\n        // Deposit the NFT in the recipient's collection\n        depositRef.deposit(token: <-nft)\n    }\n}",
    "update_nft_catalog_entry": "import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(\n        collectionIdentifier : String,\n        contractName: String,\n        contractAddress: Address,\n        nftTypeIdentifer: String,\n        addressWithNFT: Address,\n        publicPathIdentifier: String\n) {\n        let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n        prepare(acct: AuthAccount) {\n                self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n        }\n\n        execute {\n                let nftAccount = getAccount(addressWithNFT)\n                let pubPath = PublicPath(identifier: publicPathIdentifier)!\n                let collectionCap = nftAccount.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(pubPath)\n                assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n                let collectionRef = collectionCap.borrow()!\n                assert(collectionRef.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n                let testNftId = collectionRef.getIDs()[0]\n                let nftResolver = collectionRef.borrowViewResolver(id: testNftId)\n                \n                let metadataCollectionData = nftResolver.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData\n                \n                let collectionData = NFTCatalog.NFTCollectionData(\n                        storagePath: metadataCollectionData.storagePath,\n                        publicPath: metadataCollectionData.publicPath,\n                        privatePath: metadataCollectionData.providerPath,\n                        publicLinkedType : metadataCollectionData.publicLinkedType,\n                        privateLinkedType : metadataCollectionData.providerLinkedType\n                )\n\n                let collectionDisplay = nftResolver.resolveView(Type<MetadataViews.NFTCollectionDisplay>())! as! MetadataViews.NFTCollectionDisplay\n\n                let catalogData = NFTCatalog.NFTCatalogMetadata(\n                        contractName: contractName,\n                        contractAddress: contractAddress,\n                        nftType: CompositeType(nftTypeIdentifer)!,\n                        collectionData: collectionData,\n                        collectionDisplay : collectionDisplay\n                )\n                \n                self.adminProxyResource.getCapability()!.borrow()!.updateCatalogEntry(collectionIdentifier : collectionIdentifier, metadata : catalogData)\n        }\n}",
    "withdraw_nft_proposal_from_catalog": "import NFTCatalog from 0xNFTCatalog\n\ntransaction(\n    proposalID : UInt64\n) {\n    let nftCatalogProposalResourceRef : &NFTCatalog.NFTCatalogProposalManager\n\n    prepare(acct: AuthAccount) {\n        self.nftCatalogProposalResourceRef = acct.borrow<&NFTCatalog.NFTCatalogProposalManager>(from: NFTCatalog.ProposalManagerStoragePath)!\n    }\n\n    execute {\n        let proposal = NFTCatalog.getCatalogProposalEntry(proposalID: proposalID)!\n        \n        self.nftCatalogProposalResourceRef.setCurrentProposalEntry(identifier : proposal.collectionIdentifier)\n        NFTCatalog.withdrawNFTProposal(proposalID : proposalID)\n        self.nftCatalogProposalResourceRef.setCurrentProposalEntry(identifier : nil)\n    }\n}"
  },
  "scripts": {
    "check_for_recommended_v1_views": "import MetadataViews from 0xMetadataViews\nimport NFTRetrieval from 0xNFTRetrieval\n\n/*\n    Script to check for the implementation of all recommended MetadataViews.\n */\npub fun main(ownerAddress: Address, collectionStoragePath: StoragePath, nftID: UInt64): {String: Bool} {\n    let owner = getAuthAccount(ownerAddress)\n    let tempPathStr = \"recommnededV1ViewsNFTCatalog\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    owner.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: collectionStoragePath\n    )\n    \n    let collectionCap = owner.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n    assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n    let collection = collectionCap.borrow()!\n    assert(collection.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n    let nftResolver = collection.borrowViewResolver(id: nftID)\n    let views: {String: Bool} = {}\n    // Initialize map to all falses for recommended views.\n    for view in NFTRetrieval.getRecommendedViewsTypes(version: \"v1\") {\n        views.insert(key: view.identifier, false)\n    }\n    // Set to true if supported.\n    for view in nftResolver.getViews() {\n        if views.containsKey(view.identifier) {\n            views.insert(key: view.identifier, true)\n        }\n    }\n    return views\n}",
    "get_all_nfts_in_account": "import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct NFT {\n    pub let id : UInt64\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n    pub let externalURL : String\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : String\n    pub let collectionBannerImage : String\n    pub let royalties: [MetadataViews.Royalty]\n\n    init(\n            id: UInt64,\n            name : String,\n            description : String,\n            thumbnail : String,\n            externalURL : String,\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n            collectionName : String,\n            collectionDescription : String,\n            collectionSquareImage : String,\n            collectionBannerImage : String,\n            royalties : [MetadataViews.Royalty]\n    ) {\n        self.id = id\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n        self.externalURL = externalURL\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.royalties = royalties\n    }\n}\n\npub fun main(ownerAddress: Address) : { String : [NFT] } {\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n    let items : [NFTRetrieval.BaseNFTViewsV1] = []\n    \n    let data : {String : [NFT] } = {}\n\n    for key in catalog.keys {\n        let value = catalog[key]!\n        let tempPathStr = \"catalog\".concat(key)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: value.collectionData.storagePath\n        )\n        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n        assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n        let views = NFTRetrieval.getNFTViewsFromCap(collectionIdentifier : key, collectionCap : collectionCap)\n\n        let items : [NFT] = []\n        for view in views {\n            let displayView = view.display\n            let externalURLView = view.externalURL\n            let collectionDataView = view.collectionData\n            let collectionDisplayView = view.collectionDisplay\n            let royaltyView = view.royalties\n            if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n                // Bad NFT. Skipping....\n                continue\n            }\n\n            items.append(\n                NFT(\n                    id: view.id,\n                    name : displayView!.name,\n                    description : displayView!.description,\n                    thumbnail : displayView!.thumbnail.uri(),\n                    externalURL : externalURLView!.url,\n                    storagePath : collectionDataView!.storagePath,\n                    publicPath : collectionDataView!.publicPath,\n                    privatePath : collectionDataView!.providerPath,\n                    publicLinkedType : collectionDataView!.publicLinkedType,\n                    privateLinkedType : collectionDataView!.providerLinkedType,\n                    collectionName : collectionDisplayView!.name,\n                    collectionDescription : collectionDisplayView!.description,\n                    collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n                    collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n                    royalties : royaltyView!.getRoyalties()\n                )\n            )\n        }\n        data[key] = items\n    }\n    return data\n}\n",
    "get_examplenft_collection_length": "import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\n\npub fun main(address: Address): Int {\n    let account = getAccount(address)\n\n    let collectionRef = account\n        .getCapability(ExampleNFT.CollectionPublicPath)\n        .borrow<&{NonFungibleToken.CollectionPublic}>()\n        ?? panic(\"Could not borrow capability from public collection\")\n    \n    return collectionRef.getIDs().length\n}",
    "get_examplenft_type": "import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\n\npub fun main(): String {\n    return Type<@ExampleNFT.NFT>().identifier\n}",
    "get_nft_catalog": "import NFTCatalog from 0xNFTCatalog\n\npub fun main(): {String : NFTCatalog.NFTCatalogMetadata} {\n    return NFTCatalog.getCatalog()\n}",
    "get_nft_catalog_proposals": "import NFTCatalog from 0xNFTCatalog\n\npub fun main(): {UInt64 : NFTCatalog.NFTCatalogProposal} {\n    return NFTCatalog.getCatalogProposals()\n}",
    "get_nft_collections_for_nft_type": "import NFTCatalog from 0xNFTCatalog\n\npub fun main(nftTypeIdentifer: String): {String : Bool}? {\n    return NFTCatalog.getCollectionsForType(nftTypeIdentifier: CompositeType(nftTypeIdentifer)!.identifier)\n}",
    "get_nft_in_account": "import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct NFT {\n    pub let id : UInt64\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n    pub let externalURL : String\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : String\n    pub let collectionBannerImage : String\n    pub let royalties: [MetadataViews.Royalty]\n\n    init(\n            id: UInt64,\n            name : String,\n            description : String,\n            thumbnail : String,\n            externalURL : String,\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n            collectionName : String,\n            collectionDescription : String,\n            collectionSquareImage : String,\n            collectionBannerImage : String,\n            royalties : [MetadataViews.Royalty]\n    ) {\n        self.id = id\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n        self.externalURL = externalURL\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.royalties = royalties\n    }\n}\n\npub fun main(ownerAddress: Address, collectionIdentifier : String, tokenID: UInt64) : NFT? {\n        let catalog = NFTCatalog.getCatalog()\n\n        assert(catalog.containsKey(collectionIdentifier), message: \"Invalid Collection\")\n        \n        let account = getAuthAccount(ownerAddress)\n        \n        let value = catalog[collectionIdentifier]!\n        let tempPathStr = \"catalog\".concat(collectionIdentifier)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: value.collectionData.storagePath\n        )\n        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n        assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n        let views = NFTRetrieval.getNFTViewsFromCap(collectionIdentifier : collectionIdentifier, collectionCap : collectionCap)\n        \n        for view in views {\n            if view.id == tokenID {\n                let displayView = view.display\n                let externalURLView = view.externalURL\n                let collectionDataView = view.collectionData\n                let collectionDisplayView = view.collectionDisplay\n                let royaltyView = view.royalties\n                if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n                    // Bad NFT. Skipping....\n                    return nil\n                }\n                return NFT(\n                    id: view.id,\n                    name : displayView!.name,\n                    description : displayView!.description,\n                    thumbnail : displayView!.thumbnail.uri(),\n                    externalURL : externalURLView!.url,\n                    storagePath : collectionDataView!.storagePath,\n                    publicPath : collectionDataView!.publicPath,\n                    privatePath : collectionDataView!.providerPath,\n                    publicLinkedType : collectionDataView!.publicLinkedType,\n                    privateLinkedType : collectionDataView!.providerLinkedType,\n                    collectionName : collectionDisplayView!.name,\n                    collectionDescription : collectionDisplayView!.description,\n                    collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n                    collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n                    royalties : royaltyView!.getRoyalties()\n                )\n            }\n        }\n        panic(\"Invalid Token ID\")\n}",
    "get_nft_in_account_from_path": "import MetadataViews from 0xMetadataViews\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct DisplayView {\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n\n    init (\n        name : String,\n        description : String,\n        thumbnail : String,\n    ) {\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n    }\n}\n\npub struct ExternalURLView {\n    pub let externalURL : String\n\n    init (\n        externalURL : String\n    ) {\n        self.externalURL = externalURL\n    }\n}\n\npub struct NFTCollectionDataView {\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n\n    init (\n        storagePath : StoragePath,\n        publicPath : PublicPath,\n        privatePath : PrivatePath,\n        publicLinkedType : Type,\n        privateLinkedType : Type,\n    ) {\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n    }\n}\n\npub struct NFTCollectionDisplayView {\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : MetadataViews.Media\n    pub let collectionBannerImage : MetadataViews.Media\n    pub let socials : {String: MetadataViews.ExternalURL}\n\n    init (\n        collectionName : String,\n        collectionDescription : String,\n        collectionSquareImage : MetadataViews.Media,\n        collectionBannerImage : MetadataViews.Media,\n        socials : {String: MetadataViews.ExternalURL}\n    ) {\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.socials = socials\n    }\n}\n\npub struct RoyaltiesView {\n    pub let royalties: [MetadataViews.Royalty]\n\n    init (\n        royalties : [MetadataViews.Royalty]\n    ) {\n        self.royalties = royalties\n    }\n}\n\npub struct NFT {\n    pub let id : UInt64\n    pub let display : DisplayView?\n    pub let externalURL : ExternalURLView?\n    pub let nftCollectionData : NFTCollectionDataView?\n    pub let nftCollectionDisplay : NFTCollectionDisplayView?\n    pub let royalties : RoyaltiesView?\n\n    init(\n            id: UInt64,\n            display : DisplayView?,\n            externalURL : ExternalURLView?,\n            nftCollectionData : NFTCollectionDataView?,\n            nftCollectionDisplay : NFTCollectionDisplayView?,\n            royalties : RoyaltiesView?\n    ) {\n        self.id = id\n        self.display = display\n        self.externalURL = externalURL\n        self.nftCollectionData = nftCollectionData\n        self.nftCollectionDisplay = nftCollectionDisplay\n        self.royalties = royalties\n}\n\npub fun getMapping() : {String : AnyStruct} {\n    return {\n        \"Id\" : self.id,\n        \"Display\" : self.display,\n        \"ExternalURL\" : self.externalURL,\n        \"NFTCollectionData\" : self.nftCollectionData,\n        \"NFTCollectionDisplay\" : self.nftCollectionDisplay,\n        \"Royalties\" : self.royalties\n    }\n}\n\n}\n\npub fun main(ownerAddress: Address, storagePathIdentifier: String, nftID: UInt64): {String : AnyStruct}    {\n    let owner = getAuthAccount(ownerAddress)\n    \n    let tempPathStr = \"getNFTsInAccountFromPathNFTCatalog\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    owner.link<&{MetadataViews.ResolverCollection}>(\n        tempPublicPath,\n        target: StoragePath(identifier : storagePathIdentifier)!\n    )\n\n    let collectionCap = owner.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n    assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n    let collection = collectionCap.borrow()!\n    assert(collection.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n\n    return getNFTData(nftID: nftID, collection: collection)\n}\n\n\npub fun getNFTData(nftID: UInt64, collection: &AnyResource{MetadataViews.ResolverCollection} ): {String : AnyStruct} {\n    let nftResolver = collection.borrowViewResolver(id: nftID)\n    let nftViews = NFTRetrieval.getBasedNFTViewsV1(\n        id : nftID,\n        nftResolver: nftResolver\n    )\n\n    let displayView = nftViews.display\n    let externalURLView = nftViews.externalURL\n    let collectionDataView = nftViews.collectionData\n    let collectionDisplayView = nftViews.collectionDisplay\n    let royaltyView = nftViews.royalties\n\n    var display : DisplayView? = nil\n    if displayView != nil {\n        display = DisplayView(\n            name : displayView!.name,\n            description : displayView!.description,\n            thumbnail : displayView!.thumbnail.uri()\n        )\n    }\n\n    var externalURL : ExternalURLView? = nil\n    if externalURLView != nil {\n        externalURL = ExternalURLView(\n            externalURL : externalURLView!.url,\n        )\n    }\n\n    var nftCollectionData : NFTCollectionDataView? = nil\n    if collectionDataView != nil {\n        nftCollectionData = NFTCollectionDataView(\n            storagePath : collectionDataView!.storagePath,\n            publicPath : collectionDataView!.publicPath,\n            privatePath : collectionDataView!.providerPath,\n            publicLinkedType : collectionDataView!.publicLinkedType,\n            privateLinkedType : collectionDataView!.providerLinkedType,\n        )\n    }\n\n    var nftCollectionDisplay : NFTCollectionDisplayView? = nil\n    if collectionDisplayView != nil {\n        nftCollectionDisplay = NFTCollectionDisplayView(\n            collectionName : collectionDisplayView!.name,\n            collectionDescription : collectionDisplayView!.description,\n            collectionSquareImage : collectionDisplayView!.squareImage,\n            collectionBannerImage : collectionDisplayView!.bannerImage,\n            socials : collectionDisplayView!.socials\n        )\n    }\n\n    var royalties : RoyaltiesView? = nil\n    if royaltyView != nil {\n        royalties = RoyaltiesView(\n            royalties : royaltyView!.getRoyalties()\n        )\n    }\n\n    return NFT(\n        id: nftID,\n        display : display,\n        externalURL : externalURL,\n        nftCollectionData : nftCollectionData,\n        nftCollectionDisplay : nftCollectionDisplay,\n        royalties : royalties\n    ).getMapping()\n}",
    "get_nft_metadata_for_collection_identifier": "import NFTCatalog from 0xNFTCatalog\n\npub fun main(collectionIdentifier: String): NFTCatalog.NFTCatalogMetadata? {\n    return NFTCatalog.getCatalogEntry(collectionIdentifier: collectionIdentifier)\n}",
    "get_nft_proposal_for_id": "import NFTCatalog from 0xNFTCatalog\n\npub fun main(proposalID: UInt64): NFTCatalog.NFTCatalogProposal? {\n    return NFTCatalog.getCatalogProposalEntry(proposalID: proposalID)\n}",
    "get_nfts_in_account": "import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct NFT {\n    pub let id : UInt64\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n    pub let externalURL : String\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : String\n    pub let collectionBannerImage : String\n    pub let royalties: [MetadataViews.Royalty]\n\n    init(\n            id: UInt64,\n            name : String,\n            description : String,\n            thumbnail : String,\n            externalURL : String,\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n            collectionName : String,\n            collectionDescription : String,\n            collectionSquareImage : String,\n            collectionBannerImage : String,\n            royalties : [MetadataViews.Royalty]\n    ) {\n        self.id = id\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n        self.externalURL = externalURL\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.royalties = royalties\n    }\n}\n\npub fun main(ownerAddress: Address, collectionIdentifiers: [String]) : { String : [NFT] }    {\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n    \n    let data : {String : [NFT] } = {}\n\n    for collectionIdentifier in collectionIdentifiers {\n        if catalog.containsKey(collectionIdentifier) {\n            let value = catalog[collectionIdentifier]!\n            let tempPathStr = \"catalog\".concat(collectionIdentifier)\n            let tempPublicPath = PublicPath(identifier: tempPathStr)!\n            account.link<&{MetadataViews.ResolverCollection}>(\n                tempPublicPath,\n                target: value.collectionData.storagePath\n            )\n            \n            let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n            assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n            let views = NFTRetrieval.getNFTViewsFromCap(collectionIdentifier : collectionIdentifier, collectionCap : collectionCap)\n            \n            let items : [NFT] = []\n            \n            for view in views {\n                let displayView = view.display\n                let externalURLView = view.externalURL\n                let collectionDataView = view.collectionData\n                let collectionDisplayView = view.collectionDisplay\n                let royaltyView = view.royalties\n                if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n                    // Bad NFT. Skipping....\n                    continue\n                }\n\n                items.append(\n                    NFT(\n                        id: view.id,\n                        name : displayView!.name,\n                        description : displayView!.description,\n                        thumbnail : displayView!.thumbnail.uri(),\n                        externalURL : externalURLView!.url,\n                        storagePath : collectionDataView!.storagePath,\n                        publicPath : collectionDataView!.publicPath,\n                        privatePath : collectionDataView!.providerPath,\n                        publicLinkedType : collectionDataView!.publicLinkedType,\n                        privateLinkedType : collectionDataView!.providerLinkedType,\n                        collectionName : collectionDisplayView!.name,\n                        collectionDescription : collectionDisplayView!.description,\n                        collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n                        collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n                        royalties : royaltyView!.getRoyalties()\n                    )\n                )\n            }\n            \n            data[collectionIdentifier] = items\n        }\n    }\n\n    return data\n}",
    "get_nfts_in_account_from_path": "import MetadataViews from 0xMetadataViews\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct DisplayView {\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n\n    init (\n        name : String,\n        description : String,\n        thumbnail : String,\n    ) {\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n    }\n}\n\npub struct ExternalURLView {\n    pub let externalURL : String\n\n    init (\n        externalURL : String\n    ) {\n        self.externalURL = externalURL\n    }\n}\n\npub struct NFTCollectionDataView {\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n\n    init (\n        storagePath : StoragePath,\n        publicPath : PublicPath,\n        privatePath : PrivatePath,\n        publicLinkedType : Type,\n        privateLinkedType : Type,\n    ) {\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n    }\n}\n\npub struct NFTCollectionDisplayView {\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : MetadataViews.Media\n    pub let collectionBannerImage : MetadataViews.Media\n    pub let socials : {String: MetadataViews.ExternalURL}\n\n    init (\n        collectionName : String,\n        collectionDescription : String,\n        collectionSquareImage : MetadataViews.Media,\n        collectionBannerImage : MetadataViews.Media,\n        socials : {String: MetadataViews.ExternalURL}\n    ) {\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.socials = socials\n    }\n}\n\npub struct RoyaltiesView {\n    pub let royalties: [MetadataViews.Royalty]\n\n    init (\n        royalties : [MetadataViews.Royalty]\n    ) {\n        self.royalties = royalties\n    }\n}\n\npub struct NFT {\n    pub let id : UInt64\n    pub let display : DisplayView?\n    pub let externalURL : ExternalURLView?\n    pub let nftCollectionData : NFTCollectionDataView?\n    pub let nftCollectionDisplay : NFTCollectionDisplayView?\n    pub let royalties : RoyaltiesView?\n\n    init(\n            id: UInt64,\n            display : DisplayView?,\n            externalURL : ExternalURLView?,\n            nftCollectionData : NFTCollectionDataView?,\n            nftCollectionDisplay : NFTCollectionDisplayView?,\n            royalties : RoyaltiesView?\n    ) {\n        self.id = id\n        self.display = display\n        self.externalURL = externalURL\n        self.nftCollectionData = nftCollectionData\n        self.nftCollectionDisplay = nftCollectionDisplay\n        self.royalties = royalties\n}\n\npub fun getMapping() : {String : AnyStruct} {\n    return {\n        \"Id\" : self.id,\n        \"Display\" : self.display,\n        \"ExternalURL\" : self.externalURL,\n        \"NFTCollectionData\" : self.nftCollectionData,\n        \"NFTCollectionDisplay\" : self.nftCollectionDisplay,\n        \"Royalties\" : self.royalties\n    }\n}\n\n}\n\npub fun main(ownerAddress: Address, storagePathIdentifier: String): [{String : AnyStruct}]    {\n    let owner = getAuthAccount(ownerAddress)\n    \n    let tempPathStr = \"getNFTsInAccountFromPathNFTCatalog\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    owner.link<&{MetadataViews.ResolverCollection}>(\n        tempPublicPath,\n        target: StoragePath(identifier : storagePathIdentifier)!\n    )\n\n    let collectionCap = owner.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n    assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n    let collection = collectionCap.borrow()!\n    assert(collection.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n\n    let data : [{String : AnyStruct}] = []\n\n    for nftID in collection.getIDs() {\n        data.append(getNFTData(nftID: nftID, collection: collection))\n    }\n\n    return data\n}\n\n\npub fun getNFTData(nftID: UInt64, collection: &AnyResource{MetadataViews.ResolverCollection} ): {String : AnyStruct} {\n    let nftResolver = collection.borrowViewResolver(id: nftID)\n    let nftViews = NFTRetrieval.getBasedNFTViewsV1(\n        id : nftID,\n        nftResolver: nftResolver\n    )\n\n    let displayView = nftViews.display\n    let externalURLView = nftViews.externalURL\n    let collectionDataView = nftViews.collectionData\n    let collectionDisplayView = nftViews.collectionDisplay\n    let royaltyView = nftViews.royalties\n\n    var display : DisplayView? = nil\n    if displayView != nil {\n        display = DisplayView(\n            name : displayView!.name,\n            description : displayView!.description,\n            thumbnail : displayView!.thumbnail.uri()\n        )\n    }\n\n    var externalURL : ExternalURLView? = nil\n    if externalURLView != nil {\n        externalURL = ExternalURLView(\n            externalURL : externalURLView!.url,\n        )\n    }\n\n    var nftCollectionData : NFTCollectionDataView? = nil\n    if collectionDataView != nil {\n        nftCollectionData = NFTCollectionDataView(\n            storagePath : collectionDataView!.storagePath,\n            publicPath : collectionDataView!.publicPath,\n            privatePath : collectionDataView!.providerPath,\n            publicLinkedType : collectionDataView!.publicLinkedType,\n            privateLinkedType : collectionDataView!.providerLinkedType,\n        )\n    }\n\n    var nftCollectionDisplay : NFTCollectionDisplayView? = nil\n    if collectionDisplayView != nil {\n        nftCollectionDisplay = NFTCollectionDisplayView(\n            collectionName : collectionDisplayView!.name,\n            collectionDescription : collectionDisplayView!.description,\n            collectionSquareImage : collectionDisplayView!.squareImage,\n            collectionBannerImage : collectionDisplayView!.bannerImage,\n            socials : collectionDisplayView!.socials\n        )\n    }\n\n    var royalties : RoyaltiesView? = nil\n    if royaltyView != nil {\n        royalties = RoyaltiesView(\n            royalties : royaltyView!.getRoyalties()\n        )\n    }\n\n    return NFT(\n        id: nftID,\n        display : display,\n        externalURL : externalURL,\n        nftCollectionData : nftCollectionData,\n        nftCollectionDisplay : nftCollectionDisplay,\n        royalties : royalties\n    ).getMapping()\n}",
    "has_admin_proxy": "import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\npub fun main(ownerAddress: Address) : Bool {\n    let owner = getAccount(ownerAddress)\n    let proxyCap = owner.getCapability<&NFTCatalogAdmin.AdminProxy{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath)\n    return proxyCap.check()\n}",
    "is_catalog_admin": "import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\npub fun main(ownerAddress: Address) : Bool {\n    let owner = getAccount(ownerAddress)\n    let proxyCap = owner.getCapability<&NFTCatalogAdmin.AdminProxy{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath)\n    if !proxyCap.check() {\n        return false\n    }\n    let proxyRef = proxyCap.borrow()!\n    return proxyRef.hasCapability()\n}"
  },
  "vars": {
    "emulator": {
      "0xNonFungibleToken": "0xf8d6e0586b0a20c7",
      "0xMetadataViews": "0xf8d6e0586b0a20c7",
      "0xFungibleToken": "0xee82856bf20e2aa6",
      "0xFlowToken": "0x0ae53cb6e3f42a79",
      "0xExampleNFT": "0xf8d6e0586b0a20c7",
      "0xNFTCatalog": "0xf8d6e0586b0a20c7",
      "0xNFTCatalogAdmin": "0xf8d6e0586b0a20c7",
      "0xNFTRetrieval": "0xf8d6e0586b0a20c7"
    },
    "testnet": {
      "0xNonFungibleToken": "0x631e88ae7f1d7c20",
      "0xMetadataViews": "0x631e88ae7f1d7c20",
      "0xFungibleToken": "0x9a0766d93b6608b7",
      "0xFlowToken": "0x7e60df042a9c0868",
      "0xExampleNFT": "0x37d92dad2356b641",
      "0xNFTCatalog": "0x324c34e1c517e4db",
      "0xNFTCatalogAdmin": "0x324c34e1c517e4db",
      "0xNFTRetrieval": "0x324c34e1c517e4db"
    },
    "mainnet": {
      "0xNonFungibleToken": "0x1d7e57aa55817448",
      "0xMetadataViews": "0x1d7e57aa55817448",
      "0xFungibleToken": "0xf233dcee88fe0abe",
      "0xFlowToken": "0x1654653399040a61",
      "0xExampleNFT": null,
      "0xNFTCatalog": null,
      "0xNFTCatalogAdmin": null,
      "0xNFTRetrieval": null
    }
  }
}